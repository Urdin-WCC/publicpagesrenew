#############################################################################
# Neurowitch Development Task: Appendix B - Theme System Refactoring        #
#############################################################################

# Introduction:
# Welcome! This document outlines the necessary steps to refactor the existing
# Neurowitch codebase (which reflects the completion of Modules 1 through 6)
# to support a new, more flexible multi-theme system. This is a preparatory
# step required BEFORE development on Module 7 begins.
# You MUST also read and adhere to all principles and the tech stack defined
# in "Chapter 0: Common Information & Project Principles", provided separately.
# This task involves modifying existing code, so proceed carefully.

# Objective:
# Modify the existing Neurowitch project codebase to support the new multi-theme
# architecture. This involves updating the database schema, related core
# functions, public layout rendering logic, and removing obsolete UI elements.

# Prerequisites:
# - Access to the Neurowitch project codebase *after* the completion of Module 6.
# - A working development environment with Node.js, npm/yarn, and Prisma CLI.
# - Ability to edit project files (TypeScript, Prisma Schema).

# Specific Technology:
# TypeScript, Prisma, Next.js (App Router), React.

# ---------------------------------------------------------------------------
# Detailed Responsibilities:
# ---------------------------------------------------------------------------

# 1. Update Database Schema (`prisma/schema.prisma`):
#    - Open the file: `prisma/schema.prisma`.
#    - **Add** the following model definition to the schema file:
#      ```prisma
#      model ThemePreset {
#        id     Int     @id @default(autoincrement())
#        name   String  @unique
#        config Json    // Will store detailed theme configuration object
#      }
#      ```
#    - **Locate** the existing `GlobalConfig` model definition within the schema.
#    - **Modify** the `GlobalConfig` model:
#      - **Remove** any fields related to the previous theme system. These might be named like `activeThemePresetId`, `activeDarkThemePresetId`, or similar. Check the existing model carefully.
#      - **Add** the following fields inside the `GlobalConfig` model definition block:
#        ```prisma
#        // Add these fields inside GlobalConfig:
#        defaultLightThemePresetId  Int?
#        defaultDarkThemePresetId   Int?
#        themeAssignments           Json    @default("{}") // Maps routes/elements to { light: presetId, dark: presetId }
#        loadingSpinnerConfig       Json    @default("{\"enabled\": false, \"overlayColor\": \"rgba(255,255,255,0.8)\"}")
#        themeSwitcherConfig        Json    @default("{\"enabled\": true, \"position\": \"bottom-right\"}")
#        stickyElementsConfig       Json    @default("{\"header\": false, \"sidebar\": false, \"footer\": false, \"themeSwitcher\": false}")
#
#        // Optional: Add relations if your Prisma setup requires them. Using IDs directly is often simpler.
#        // defaultLightTheme          ThemePreset? @relation(fields: [defaultLightThemePresetId], references: [id], onDelete: SetNull, onUpdate: Cascade)
#        // defaultDarkTheme           ThemePreset? @relation(fields: [defaultDarkThemePresetId], references: [id], onDelete: SetNull, onUpdate: Cascade)
#        ```
#      - Ensure the `GlobalConfig` model is correctly configured to represent only a single row (e.g., it might have `@id @default(1)` and `@@unique([id])` or a similar constraint).
#    - Save the `prisma/schema.prisma` file.

# 2. Apply Database Migration:
#    - Open your terminal.
#    - Navigate to the project's root directory.
#    - Run the following command:
#      ```bash
#      npx prisma migrate dev --name apply-theme-refactor
#      ```
#    - Prisma will generate a SQL migration file. Review it if desired, and then confirm its application to your development database when prompted.

# 3. Update Database Seed Script (`prisma/seed.ts`):
#    - Open the file: `prisma/seed.ts`.
#    - Locate the section where the `GlobalConfig` record is created or updated (likely using `prisma.globalConfig.upsert(...)`).
#    - Modify the `create` and `update` objects within this operation:
#      - Ensure it assigns values to the **new fields** you added (`defaultLightThemePresetId`, `themeAssignments`, `loadingSpinnerConfig`, `themeSwitcherConfig`, `stickyElementsConfig`). Use appropriate default values (e.g., `themeAssignments: {}`, `loadingSpinnerConfig: { enabled: false, ... }`).
#      - **Remove** any value assignments for the old theme fields that you deleted from the schema in Step 1.
#    - *(Optional but Recommended)* Add code *before* the `GlobalConfig` seeding to create one or two basic `ThemePreset` records. Capture their generated `id`s and use these to set the `defaultLightThemePresetId` and `defaultDarkThemePresetId` in the `GlobalConfig` data. Example structure:
#      ```typescript
#      // Inside the async main function of seed.ts, BEFORE seeding GlobalConfig:
#      const defaultLight = await prisma.themePreset.upsert({
#        where: { name: 'Default Light' }, update: {},
#        create: { name: 'Default Light', config: { /* minimal valid light config JSON */ } },
#      });
#      const defaultDark = await prisma.themePreset.upsert({
#        where: { name: 'Default Dark' }, update: {},
#        create: { name: 'Default Dark', config: { /* minimal valid dark config JSON */ } },
#      });
#
#      // Then, inside the create block for GlobalConfig upsert:
#      // ... other fields ...
#      defaultLightThemePresetId: defaultLight.id,
#      defaultDarkThemePresetId: defaultDark.id,
#      themeAssignments: {}, // Default empty JSON
#      loadingSpinnerConfig: { enabled: false, overlayColor: 'rgba(255,255,255,0.8)' }, // Example default
#      themeSwitcherConfig: { enabled: true, position: 'bottom-right' }, // Example default
#      stickyElementsConfig: { header: false, sidebar: false, footer: false, themeSwitcher: false }, // Example default
#      // ...
#      ```
#    - Save the `prisma/seed.ts` file.
#    - Run the seed command in your terminal:
#      ```bash
#      npx prisma db seed
#      ```

# 4. Update Core Configuration Functions (e.g., `lib/config.ts`):
#    - Identify the file containing the core functions for reading/writing `GlobalConfig` (established in Module 1, likely `lib/config.ts` or similar).
#    - Modify the `getGlobalConfig` function: Update its internal Prisma query (`prisma.globalConfig.findUnique(...)`) to fetch the record according to the *new* schema structure, returning the new fields.
#    - Modify the `updateGlobalConfig` function: Update its input parameter type and internal Prisma query (`prisma.globalConfig.update(...)`) to correctly save data matching the *new* `GlobalConfig` structure.
#    - *(Optional but Recommended)* Add new helper functions, perhaps in a new file like `lib/themeUtils.ts` or within `lib/config.ts`:
#      ```typescript
#      // Example: lib/themeUtils.ts (Make sure to import your prisma client instance)
#      import prisma from './prisma';
#
#      export async function getAllThemePresets() {
#        // Fetches only id and name, useful for dropdowns in later modules
#        return prisma.themePreset.findMany({ select: { id: true, name: true } });
#      }
#
#      export async function getThemePresetConfigById(id: number | null | undefined) {
#        if (id == null) return null;
#        const preset = await prisma.themePreset.findUnique({
#          where: { id },
#          select: { config: true }, // Only fetch the config JSON
#        });
#        // Add error handling or type casting for config as needed
#        return preset?.config as any || null;
#      }
#      ```

# 5. Update Public Layout Component (`app/(public)/layout.tsx`):
#    - Open the main public layout file: `app/(public)/layout.tsx`.
#    - **Refactor Data Fetching Logic:** Modify the component's logic (likely near the top if it's a Server Component) to:
#      - Call the updated `getGlobalConfig()` function.
#      - Determine the applicable `currentLightThemeId` and `currentDarkThemeId`. Use the request context (e.g., route/pathname) to check the `globalConfig.themeAssignments` JSON. If no specific entry is found for the current context, fall back to `globalConfig.defaultLightThemePresetId` and `globalConfig.defaultDarkThemePresetId`.
#      - Fetch the `config` JSON objects for *both* the determined light and dark theme IDs (e.g., using `getThemePresetConfigById` from step 4). Handle potential null IDs or configs.
#    - **Implement Dynamic CSS Generation:**
#      - Create a TypeScript function (can be defined within the layout or imported) that accepts the light and dark theme `config` JSON objects.
#      - This function *must* return a single CSS string.
#      - The string should define CSS Custom Properties (variables) for styling (e.g., `--primary-color`, `--text-color`, `--card-bg`, etc.).
#      - Define these variables based on the light theme config inside a `:root { ... }` selector.
#      - Define the *same* variables based on the dark theme config inside an `html.dark:root { ... }` selector.
#      - Example structure within the generated string:
#        `:root { --primary-color: #0066cc; --background-color: #ffffff; } html.dark:root { --primary-color: #3399ff; --background-color: #1a1a1a; }`
#      - Ensure the function handles missing properties in the config JSONs gracefully (e.g., omit the CSS variable or use a fallback).
#    - **Inject Generated CSS into `<head>`:**
#      - Inside the JSX returned by the layout component, locate the `<head>` section.
#      - Render the generated CSS string using a `<style>` tag like this:
#        ```jsx
#        <style
#          id="dynamic-theme-styles"
#          dangerouslySetInnerHTML={{ __html: generatedCssString }} /* where generatedCssString holds the CSS output */
#        />
#        ```
#    - **Update Conditional Rendering/Configuration for UI Elements:**
#      - Find where components like `LoadingSpinner` and `ThemeSwitcher` are rendered within the layout.
#      - Update the conditional logic (e.g., `if (globalConfig.loadingSpinnerConfig.enabled)`) to use the new configuration fields from `GlobalConfig` (i.e., `loadingSpinnerConfig`, `themeSwitcherConfig`).
#      - Pass the relevant configuration details (e.g., `overlayColor`, `spinnerImageUrl`, `position`, `style`) from these config objects as props down to the components.
#    - **Update Sticky Element Logic:**
#      - Find where CSS classes related to sticky positioning (e.g., `sticky`, `fixed`) are applied (could be on `<body>`, `header`, `footer` wrappers).
#      - Update this logic to read the boolean flags from the new `globalConfig.stickyElementsConfig` JSON field.

# 6. Clean Up Obsolete Admin UI (from Module 4 output):
#    - Navigate to the directory containing the admin settings pages created previously by Module 4 (likely `app/(admin)/admin/settings/`).
#    - Examine the files/components related to Header, Footer, Sidebar, or any general settings page created in Module 4.
#    - Identify any UI elements (input fields, selects, sections, buttons) that were specifically used to configure the *old* theme system (e.g., selecting a single active light/dark theme).
#    - **Remove or comment out** these obsolete UI elements entirely. The new appearance configuration interface will be created in a later module. Do not remove configurations unrelated to the old theme system (like header logo upload, footer text, social links if they exist).

# 7. Verification:
#    - After completing all steps, run the development server: `npm run dev`.
#    - Open the application in your browser. Check the browser's developer console and the terminal for any errors related to Prisma, data fetching, or component rendering.
#    - Load a public page (e.g., the homepage). Use the browser's developer tools to inspect the `<head>` element. Verify that a `<style id="dynamic-theme-styles">` tag exists and contains CSS variables within `:root` and `html.dark:root` selectors.
#    - Navigate to the admin settings pages you modified in step 6. Confirm that the UI elements related to the *old* theme configuration are no longer visible.

# Completion:
# Once all steps are completed and verified, the codebase is refactored and ready
# for the development of subsequent modules (starting with Module 7) which
# will utilize this new theme system architecture. Ensure all changes are
# committed to version control.

#############################################################################
# End of Task: Appendix B - Theme System Refactoring                        #
#############################################################################